/** @import * as API from '@ucanto/interface' */
/**
 * Capability can only be delegated (but not invoked) allowing audience to
 * derived any `space/blob/` prefixed capability for the space identified
 * by DID in the `with` field.
 */
export const content: API.TheCapabilityParser<API.CapabilityMatch<"space/content/*", `did:key:${string}` & `did:${string}` & API.Phantom<{
    protocol: "did:";
}>, any>>;
/**
 * Capability allowing blob content to be retrieved (typically as a DAG) via
 * byte range requests.
 */
export const retrieve: API.TheCapabilityParser<API.CapabilityMatch<"space/content/retrieve", `did:key:${string}` & `did:${string}` & API.Phantom<{
    protocol: "did:";
}>, Schema.InferStruct<{
    blob: Schema.StructSchema<{
        digest: Schema.Schema<Uint8Array<ArrayBufferLike>, unknown>;
    }, any>;
    range: Schema.Schema<[number & API.Phantom<{
        typeof: "integer";
    }>, number & API.Phantom<{
        typeof: "integer";
    }>], any>;
}>>>;
export function equalDigest<T extends API.ParsedCapability<API.Ability, API.URI, {
    blob: {
        digest: Uint8Array;
    };
}>>(claimed: T, delegated: T): Schema.Result<{}, Schema.Error>;
export function equalByteRange<T extends API.ParsedCapability<API.Ability, API.URI, {
    range: number[];
}>>(claimed: T, delegated: T): Schema.Result<{}, Schema.Error>;
export { Schema };
import type * as API from '@ucanto/interface';
import { Schema } from '@ucanto/validator';
//# sourceMappingURL=content.d.ts.map